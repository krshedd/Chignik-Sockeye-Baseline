---
title: "Chignik 2018 sockeye baseline update"
subtitle: "Sockeye_UW_7SNPs"
creator: Chase Jalbert
date: 08/24/2018
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

# Introduction with notes and key steps to follow / incorporate

old but good to follow:
V:\Analysis\4_Westward\Sockeye\Chignik Inseason 2012-2018\Baseline

fairly recent ish:
V:\Analysis\4_Westward\Sockeye\KMA Commercial Harvest 2014-2016\GitHub-KMA-Sockeye-Mixtures


To get names of new markers, Locus control    
-create with sock 2011 96    
+CreateLocusControl.GCL(markersuite = "Sockeye2011_96SNPs", username = username, password = password)    
+extract locus names as object    
+rm(locuscontrol)    
-create locus control with 7 new ones    
+CreateLocusControl.GCL(markersuite = "Sockeye2011_96SNPs", username = username, password = password)    
+extract locus names as object    
+rm(locuscontrol)    
-make new list of locus names using correct spelling from 96 andf 7 lists    


LOKI2R Makes .gcl objects and sillyvec will be list of sillys    
-(can get list from :readproject")    

Key steps:    
1 -QC    
2 -analysis    
HWE    
pool    
HWE    
LD    
markers that are poor    



```{r setup}
#knitr::opts_knit$set(root.dir="V:/Analysis/4_Westward/Sockeye/Chignik Inseason 2012-2018/Baseline/GitHub-Chignik-Sockeye-Baseline") #set wd for all chunks.

#Uncomment to delete everything from environment...
#ls()
#rm(list=ls(all=TRUE))
#search()

getwd() #verify the wd has been set to the project dir (all chunks!)

if (!require("pacman"))
  install.packages("pacman")
library(pacman) # install pacman, if not installed
p_load(adegenet, tidyverse, ape, genepop, pegas, reshape) # use pacman to load or install+load necessary packages

#This sources all of the new GCL functions to this workspace
source("C:/Users/csjalbert/Documents/r_proj/function_gcl.r")
```


LOKI username and password:    
<i>intentionally hidden from output</i>
```{r user_pwd, include = FALSE}
# yourloki username 
username <- "csjalbert"

# your loki password
.password <- "esox.1234"
```



# Full Marker suite using <b>Sockeye2011_96SNPs</b> and <b>Sockeye_UW_7SNPs</b>. 
```{r marker suite}
# create locus control for Sockeye2011_96SNPs to get locus names then remove object.
CreateLocusControl.GCL(markersuite = "Sockeye2011_96SNPs",
                       username = username,
                       password = .password)

loci_sock2011_96 <- LocusControl$locusnames

rm(LocusControl)

# create locus control for Sockeye_UW_7SNPs to get locus names then remove object.
CreateLocusControl.GCL(markersuite = "Sockeye_UW_7SNPs",
                       username = username,
                       password = .password)

loci_sockuw_7 <- LocusControl$locusnames

rm(LocusControl)

# combine into a single file
Sockeye_all_SNPs <- c(loci_sock2011_96, loci_sockuw_7)

# create locus control for all sockeye markers
CreateLocusControl.GCL(locusnames = Sockeye_all_SNPs,
                       username = username,
                       password = .password)

# clean up old locus names, using ls() which allows Regex
rm(list = ls(pattern = "^loci_sock"))
```

```{r}
# Vector of silly names for ReadLoki function
ChignikCollections <-
      c(
        "SHAT96",
        "SHAT97E",
        "SALEC97",
        "SBOUL97",
        "SBROAD97",
        "SBSPR97",
        "SCHIA97E",
        "SCHIA97M",
        "SCHIG98",
        "SCLARK96",
        "SCLRK97E",
        "SFAN97",
        "SCHIA08",
        "SCHIG08",
        "SCLARK08",
        "SCUCU08",
        "SHAT08E",
        "SWESTF08"
      ) # note - no SWESTF97 due to lack of metadata, as noted in Tyler's 2012 baseline update.


## Pull all data for each silly code and create .gcl objects for each
LOKI2R.GCL(sillyvec = ChignikCollections,
           username = username,
           password = .password)
objects(pattern = "\\.gcl")

# remove password from file
rm(.password)
```

```{r N_by_location}
## Get sample size by locus
OriginalSampleSizebyLocus <-
  SampSizeByLocus.GCL(sillyvec = ChignikCollections, loci = Sockeye_all_SNPs)
min(OriginalSampleSizebyLocus) ## 69, fine.

write.table(
  OriginalSampleSizebyLocus,
  "Output/OriginalSampleSizebyLocus.txt",
  sep = '\t',
  col.names = NA,
  row.names = T
)

apply(OriginalSampleSizebyLocus, 1, range)
```

```{r}
# saving objects
save_objects("Sockeye_all_SNPs", path = "../2018/Objects")

# load objects
load_objects(path = "../2018/Objects")

# save sillys, no quotes so each as an individual file:
save_sillys(sillyvec = ChignikCollections, path = "../2018/sillys")

# export table of sample size by locus, csv since nice tidy df already and not R dependent.
write_csv(OriginalSampleSizebyLocus, path = "../2018/Output/samplesizebylocus.csv")
```


# QA section, obtain number of individuals in collections

```{r original_N}
# get number of individuals in SILLY, for all sillys, prior to removing missing loci individuals
OriginalColSize <-
  sapply(paste(ChignikCollections, ".gcl", sep = ''), function(x)
    get(x)$n)

write.table(
  OriginalColSize,
  file = "../2018/Output/OriginalColSize.csv",
  sep = ",",
  col.names = NA,
  row.names = T
)
```


```{r remove_20per}
# Remove individuals with >20% missing data
MissLoci <-
  RemoveIndMissLoci.GCL(sillyvec = ChignikCollections, proportion = 0.8)

write.table(
  MissLoci,
  file = "../2018/Output/missing.csv",
  sep = ",",
  col.names = NA,
  row.names = T
) # xxxcheck this," arguments imply differing number of rows..." 
```

Get the number of individuals per silly after removing the missing loci inds

```{r MissingLoci}
ColSizePostMissLoci <-
  sapply(paste(ChignikCollections, ".gcl", sep = ''), function(x)
    get(x)$n)

write.table(
  OriginalColSize,
  file = "../2018/Output/ColSizePostMissLoci.csv",
  sep = ",",
  col.names = NA,
  row.names = T
)

#calculate difference
OriginalColSize - ColSizePostMissLoci
```


Create matrix for collection information

```{r CollectionInfo}
Chignik2018SockeyeSampleSizes <-
  matrix(
    data = NA,
    nrow = 18,
    ncol = 4,
    dimnames = list(
      names(OriginalColSize),
      c("Initial", "Missing", "Duplicate", "Final")
    )
  )

Chignik2018SockeyeSampleSizes[, 1] <- OriginalColSize

Chignik2018SockeyeSampleSizes[, 2] <-
  OriginalColSize - ColSizePostMissLoci
```


Check within collections for duplicate individuals, at 95% level

```{r DupCheck}
DuplicateCheck95MinProportion <-
  CheckDupWithinSilly.GCL(
    sillyvec = ChignikCollections,
    loci = Sockeye_all_SNPs,
    quantile = NULL,
    minproportion = 0.95
  )

#str(DuplicateCheck95MinProportion)

# create a report summary of duplciates
DuplicateCheckReportSummary <-
  sapply(ChignikCollections, function(x)
    DuplicateCheck95MinProportion[[x]]$report)

## Remove duplicate individuals
RemovedDups <- RemoveDups.GCL(DuplicateCheck95MinProportion)

## Get number of individuals per silly after removing duplicate individuals
ColSizePostDuplicate <-
  sapply(paste(ChignikCollections, ".gcl", sep = ''), function(x)
    get(x)$n)

# write table containing duplicates
write.table(
  ColSizePostDuplicate,
  file = "../2018/Output/ColSizePostDuplicate.csv",
  sep = ",",
  col.names = NA,
  row.names = T
)

#check N lost
ColSizePostMissLoci - ColSizePostDuplicate

# write output to matrix created above
Chignik2018SockeyeSampleSizes[, 3] <-
  ColSizePostMissLoci - ColSizePostDuplicate

Chignik2018SockeyeSampleSizes[, 4] <- ColSizePostDuplicate
```

# Allele frequency plots

```{r allele freq setup}
#import list of silly, groups, and locations
Groups <- read_csv(file = "../2018/Objects/group_locations.csv")

#character vector of pop Names without the ".gcl" extension
sillyvec <- unlist(Groups[1])

#numeric vector of group numbers the same length as sillyvec
groupvec <- unlist(Groups[2])

#A numeric vector of R colors the same length as max(groupvec)
mycolor <- c("black", "red")

# assign colors for each pop, based on groups
PopCol = mycolor[(groupvec)]
```


```{r Allele frequency plots}
loci <- LocusControl$locusnames

Freq <- FreqPop.GCL(sillyvec = sillyvec, loci = loci)

Freq <-
  Freq[, , "Allele 1"] / (Freq[, , "Allele 1"] + Freq[, , "Allele 2"])

pdf(
  file = "../2018/freqplots/Chignik103SNPfreqplots_popnames.pdf",
  width = 11,
  height = 8.5,
  family = "Times",
  pointsize = 20
)
for (locus in loci) {
  plot(
    Freq[, locus],
    main = locus,
    col = PopCol,
    pch = 19,
    ylim = c(0, 1),
    ylab = "Freqency",
    xlab = "Collection"
  )
  text(x = Freq[, locus], labels = sillyvec, cex = 0.7, pos = 1, srt = 90, offset = 1.5, xpd = TRUE) # add population names to file
  lines(supsmu(seq(length(sillyvec)), Freq[, locus]))
}

rm(locus)

dev.off()
```

# Test for HWE

Here I am going to test for HWE using genepop package, so we dont have to export and analyze outside of the R-environement (sort of). All genepop does is export the .txt file, then read that file and run genepop, within r, but outputs to a .P file. There is no R output, so we have to read the .P file in using ReadGenepopHWE.GCL. This is handy because it avoids having to run gnepop.exe outside of the R session, hence avoids manually moving files.    

Another option is to export a genepop file, reimport as genind, then run hw.test (pegas package). A brief look shows that Pegas and genepop produce similar estimates of HWE. After talking to Kyle, it was decided that genepop is the standard so we will rely on that program / package for our analyses. 

```{r HWE}
# first convert to genepop format using GCL functions
gcl2Genepop.GCL(
  sillyvec = ChignikCollections,
  loci = loci,
  path = "../2018/genepop/ChignikCollections.txt",
  VialNums = T
)

# HW genotypic proportions using 'genepop'
test_HW("../2018/genepop/ChignikCollections.txt", which = "Proba")

# parse results using GCL function
HWE <-
  ReadGenepopHWE.GCL(file = "../2018/genepop/ChignikCollections.txt.P")

str(HWE)
```


Now we can identify any fixed loci. It looks like One_txnip_401 (18) and probably One_metA-253 (17.99451) - all others seem okay, although some fairly close to fixed.

```{r}
FixedSNPs <- sort(apply(Freq, 2, sum))

FixedSNPs <- names(FixedSNPs[FixedSNPs == 0 | FixedSNPs == 18])
```


```{r}
test_HW("../2018/genepop/ChignikCollections.txt", which = "Proba")
HWE <-
  ReadGenepopHWE.GCL(file = "../2018/genepop/ChignikCollections.txt.P")
str(HWE)

# just nuclear loci
locinuclear <- loci[LocusControl$ploidy == 2]

# convert to genepop format
gcl2Genepop.GCL(
  sillyvec = ChignikCollections,
  loci = locinuclear,
  path = "../2018/genepop/ChignikCollectionsnuclearloci.txt",
  VialNums = TRUE
)

# HW genotypic proportions using 'genepop'
test_HW("../2018/genepop/ChignikCollectionsnuclearloci.txt", which = "Proba")

# parse results using GCL function
HWE.N <-
  ReadGenepopHWE.GCL(file = "../2018/genepop/ChignikCollectionsnuclearloci.txt.P")
str(HWE.N)
```

# Linkage disequilibrium

Here I am going to test for LD among the 7 new RAD SNPs from Wes Larson's "Islands of Divergence" paper. Included in his paper, is Supplemental Table S4 which includes position information for these 7 SNPs based on their linkage map. Based on Table S4, 6 of the 7 SNPs appear to be on linkage group 13, with one on LG 12. This gives us enough information to *a priori* assume that we can only select one of the LG 13 SNPs in addition to the LG 12 SNP.

I ran Genepop from the executible for the file "genepop/ChignikCollections.txt", which has all 103 SNPS and all 18 Chignik collections. Here we can read in the results and see what is statistically in LD.

```{r read_LD}
(LD <- ReadGenepopDis.GCL(file = "../2018/genepop/ChignikCollections.txt.DIS") %>% 
  as_tibble())
```
Typically we determine that two markers are linked if they are P < 0.5 for 1/2 of all populations/collections.

```{r LD_npops}
LD <- LD %>% 
  gather(silly, pvalue, -Locus1, -Locus2, -Overall) %>% 
  group_by(Locus1, Locus2) %>% 
  mutate(n_pops_fail = sum(pvalue < 0.05)) %>% 
  spread(silly, pvalue)

LD %>% 
  ggplot(aes(x = n_pops_fail)) +
  geom_histogram() +
  geom_vline(xintercept = 9)
```

Which pairs of loci are "linked" according to the 1/2 pops P < 0.5 rule?

```{r LD_fail}
LD %>% 
  filter(n_pops_fail >= 9) %>% 
  select(Locus1, Locus2, Overall, n_pops_fail) %>% 
  arrange(Locus1, Locus2)
```

Some of these are not surprising since we already know that the two mitochondrial markers are linked, as well as *MHC* and *Tf_ex*.

Since we are most interested in the linkage relationships among the 7 Islands of Divergence RAD SNPs, let's just look at those.

```{r LD_RAD}
RAD_loci <- grep(pattern = "RAD", x = unique(c(LD$Locus1, LD$Locus2)), value = TRUE)

LD %>% 
  filter(Locus1 %in% RAD_loci & Locus2 %in% RAD_loci) %>% 
  select(Locus1, Locus2, Overall, n_pops_fail) %>% 
  ggplot(aes(x = Locus1, y = Locus2, fill = n_pops_fail)) + 
  geom_tile() + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
  ggtitle("Number of pops with LD P < 0.05\nIslands of Divergence RAD SNPs")
```

Based on the allele frequency plots generated above and the linkage information that we already knew about from Table S4, it looks like we'd be safe adding *One_RAD18507* and *One_RAD27165* to our **inseason marker panel of 24 SNPs**. Since we are adding two SNPs, we need to kick out two of the old ones currently in *loci22*. Based on Tyler's work for the 2012 version of this baseline (see "../2012/2012 Chignik Baseline.xlsx" tab "87 to 24"), we can conclude that the two "best" SNPs to drop would be *One_U503-170* and *One_ZNF-61*.

## Final marker panel decisions
**Add** the following two RAD SNPs from Wes' Islands of Divergence work

1. *One_RAD18507*
2. *One_RAD27165*

**Drop** the following two "old" loci in *loci22* from the 2012 baseline 

1. *One_U503-170*
2. *One_ZNF-61*

Save this updated markerset as *loci22_RAD*.
```{r loci22_RAD}
loci22 <- dget(file = "../../Mixtures/2018/Objects/loci22.txt")

loci22_RAD <-
  sort(c(setdiff(loci22, c(
    "One_U503-170", "One_ZNF-61"
  )), "One_RAD18507", "One_RAD27165"))

save_objects(objects = "loci22_RAD", path = "../2018/Objects/")
```


# Combining Loci

This is where combining loci
```{r combining loci}
CombineLoci.GCL(sillyvec = sillyvec ,markerset = c("GDPH1", "GDPH2"),update = T)
CombineLoci.GCL(sillyvec = sillyvec ,markerset = c("MCH1", "MHC2"),update = T)
```






--- <i> BEGIN CODE ARCHIVE </i> ---

Initially, I carried out pooling similar to Tyler's original 2012 baseline and found large differences at pooling test 1. Temportal locations showed some differences in overall p-values but the pooling test 1 lead to significant changes in overall p-values and changes in the individual values. I tested one  pooled collection, "SHAT96", "SCLARK96", and found that our RAD marker of interest was driving these chances. This marker was selected based on LD and Wes Larson's paper as described in the <i> Linkage disequilibrium </i> section above.    

I decided to re-run the pooling steps using ONLY the markers of interest. These are listed in object "loci22_RAD" and are as follows:     
    
     c("One_ACBP-79", "One_agt-132", "One_cin-177", "One_CO1", "One_ghsR-66", "One_GPDH2.One_GPDH", "One_HpaI-436", "One_MHC2_251.One_MHC2_190", "One_ODC1-196", "One_RAD18507", "One_RAD27165", "One_RAG3-93", "One_redd1-414", "One_sys1-230", "One_Tf_ex3-182", "One_U1003-75", "One_U1004-183", "One_U1009-91", "One_U1012-68", "One_U1016-115", "One_U1209-111", "One_U1212-106") 
  

For example, here are the allelee frequency plots and information for 

<i> Note: In the spirit of record keeping, I've kept the original code below. This was used dfuring the intially pooling attempts. Not recommended to run this code. </i>


<!-- # Pooling -->

<!-- Data cleanup and checks -->
<!-- ```{r} -->
<!-- hist(HWE.N$SummaryPValues["One_sys1-230", ], breaks = seq(0, 1, by = 0.05)) -->

<!-- # To see if there are iissues, we can filter by above marker and see which way WC FIS is leaning (i.e., consistent or not). -->
<!-- # I don't see any trends so it's likely fine. -->
<!-- HWE.N$DataByPop %>% -->
<!--   filter(Locus == "One_sys1-230") %>% -->
<!--   select(starts_with("WC")) -->


<!-- hist(HWE.N$SummaryPValues["One_STC-410", ], breaks = seq(0, 1, by = 0.05)) -->
<!-- ``` -->

<!-- So, we removed all fixed loci and those which significaly departed from HWE (P<0.1), note the P-value is not the same here as in the ADFG publication. -->

<!-- ```{r} -->
<!-- # drop 2 below 0.1, and 2 fixed -->
<!-- locidrop <- -->
<!--   c("One_sys1-230", # p-val -->
<!--     "One_STC-410", # p-val -->
<!--     "One_txnip_401", #fixed -->
<!--     "One_metA-253") #fixed -->

<!-- locipostdrop <- loci[!loci %in% locidrop] -->

<!-- Chignik_Freq <- -->
<!--   FreqPop.GCL(sillyvec = ChignikCollections, loci = locipostdrop) -->

<!-- str(Chignik_Freq) -->
<!-- ``` -->


<!-- ## Temporal Pooling Test ## -->
<!-- ```{r ,warning=FALSE} -->
<!-- #import list of silly, groups, and locations -->
<!-- Groups <- read_csv(file = "../2018/Objects/group_locations.csv") -->

<!-- #add collections were collected during mutliple years. Somtimes Early and Late are different so here I am only looking at the early (##E) or 'normal' collections (##). -->
<!-- ChignikTemporalPool <- -->
<!--   list( -->
<!--     ChignikCollections[ChignikCollections %in% c("SCHIA97E", "SCHIA08")], -->
<!--     ChignikCollections[ChignikCollections %in% c("SCHIG98", "SCHIG08")], -->
<!--     ChignikCollections[ChignikCollections %in% c("SCLRK97E", "SCLARK08")], -->
<!--     ChignikCollections[ChignikCollections %in% c("SHAT97E", "SHAT08E")] -->
<!--   ) -->

<!-- #perform fisher test on temporal collections -->
<!-- ChignikFisherTemporalResults <- FishersTest.GCL(freq = Chignik_Freq, loci = locipostdrop, test = ChignikTemporalPool) # Note warnings here but ignored using warning = FALSE for this chunk. Warning is "'hybrid' is ignored for a 2 x 2 table" -->

<!-- sink(file="../2018/pooling/ChignikFisherTemporalResults.csv") -->
<!-- print(ChignikFisherTemporalResults) -->
<!-- sink() -->

<!-- str(ChignikFisherTemporalResults) -->
<!-- ChignikFisherTemporalResults$OverallResults -->

<!-- hist( -->
<!--   ChignikFisherTemporalResults$ResultsByLocus$SCHIA97E.SCHIA08[, 2], -->
<!--   main = "SCHIA97E.SCHIA08", -->
<!--   breaks = seq(0, 1, by = 0.05), -->
<!--   xlab = "p-value" -->
<!-- ) -->

<!-- hist( -->
<!--   ChignikFisherTemporalResults$ResultsByLocus$SCHIG98.SCHIG08[, 2], -->
<!--   main = "SCHIG98.SCHIG08", -->
<!--   breaks = seq(0, 1, by = 0.05), -->
<!--   xlab = "p-value" -->
<!-- ) -->

<!-- hist( -->
<!--   ChignikFisherTemporalResults$ResultsByLocus$SCLRK97E.SCLARK08[, 2], -->
<!--   main = "SCLRK97E.SCLARK08", -->
<!--   breaks = seq(0, 1, by = 0.05), -->
<!--   xlab = "p-value" -->
<!-- ) -->

<!-- hist( -->
<!--   ChignikFisherTemporalResults$ResultsByLocus$SHAT97E.SHAT08E[, 2], -->
<!--   main = "SHAT97E.SHAT08E", -->
<!--   breaks = seq(0, 1, by = 0.05), -->
<!--   xlab = "p-value" -->
<!-- ) -->
<!-- ``` -->

<!-- Now pooling objects... -->
<!-- Pool Temporal Collections -->
<!-- ```{r} -->
<!-- lapply(1:length(ChignikTemporalPool), -->
<!--        function(x) { -->
<!--          PoolCollections.GCL( -->
<!--            collections = ChignikTemporalPool[[x]], -->
<!--            loci = locipostdrop, -->
<!--            IDs = NULL, -->
<!--            newname = paste(ChignikTemporalPool[[x]], -->
<!--                            collapse = ".") -->
<!--          ) -->
<!--        }) -->

<!-- # show just the gcl objects, or samples. -->
<!-- ls(pattern = "^*.*[0-9].*.gcl") -->

<!-- # load temporal pooling from csv -->
<!-- ChignikTemporalCollections <- Groups$ChignikTemporalCollections %>% -->
<!--   na.omit() -->

<!-- ChignikTemporalFreq <- -->
<!--   FreqPop.GCL(sillyvec = ChignikTemporalCollections, loci = locipostdrop) -->
<!-- ``` -->


<!-- Now lets do the 1st non-temporal pooling test: -->

<!-- ## Pooling tests 1 ## -->

<!-- ```{r, warning=FALSE} -->
<!-- # First non-temporal pooling test. This was done on distance and is based on Tylers 2012 baseline. -->
<!-- ChignikPool1 <- -->
<!--   list( -->
<!--     ChignikTemporalCollections[ChignikTemporalCollections %in% c("SBROAD97", "SBSPR97")], -->
<!--     ChignikTemporalCollections[ChignikTemporalCollections %in% c("SFAN97", "SALEC97")], -->
<!--     ChignikTemporalCollections[ChignikTemporalCollections %in% c("SCHIA97E.SCHIA08", "SCHIA97M")], -->
<!--     ChignikTemporalCollections[ChignikTemporalCollections %in% c("SCUCU08", "SHAT97E.SHAT08E")], -->
<!--     ChignikTemporalCollections[ChignikTemporalCollections %in% c("SHAT96", "SCLARK96")] -->
<!--   ) -->

<!-- #perform fisher test on temporal collections -->
<!-- ChignikFisherPool1Results <- FishersTest.GCL(freq = ChignikTemporalFreq, loci = locipostdrop, test = ChignikPool1) -->

<!-- sink(file="../2018/pooling/ChignikFisherPool1Results.csv") -->
<!-- print(ChignikFisherPool1Results) -->
<!-- sink() -->

<!-- str(ChignikFisherPool1Results) -->
<!-- ChignikFisherPool1Results$OverallResults -->

<!-- hist( -->
<!--   ChignikFisherPool1Results$ResultsByLocus$SBROAD97.SBSPR97[, 2], -->
<!--   main = "SBROAD97.SBSPR97", -->
<!--   breaks = seq(0, 1, by = 0.05), -->
<!--   xlab = "p-value" -->
<!-- ) -->

<!-- hist( -->
<!--   ChignikFisherPool1Results$ResultsByLocus$SALEC97.SFAN97[, 2], -->
<!--   main = "SALEC97.SFAN97", -->
<!--   breaks = seq(0, 1, by = 0.05), -->
<!--   xlab = "p-value" -->
<!-- ) -->

<!-- hist( -->
<!--   ChignikFisherPool1Results$ResultsByLocus$SCHIA97E.SCHIA08.SCHIA97M[, 2], -->
<!--   main = "SCHIA97E.SCHIA08.SCHIA97M", -->
<!--   breaks = seq(0, 1, by = 0.05), -->
<!--   xlab = "p-value" -->
<!-- ) -->

<!-- hist( -->
<!--   ChignikFisherPool1Results$ResultsByLocus$SCUCU08.SHAT97E.SHAT08E[, 2], -->
<!--   main = "SCUCU08.SHAT97E.SHAT08", -->
<!--   breaks = seq(0, 1, by = 0.05), -->
<!--   xlab = "p-value" -->
<!-- ) -->

<!-- hist( -->
<!--   ChignikFisherPool1Results$ResultsByLocus$SHAT96.SCLARK96[, 2], -->
<!--   main = "SHAT96.SCLARK96", -->
<!--   breaks = seq(0, 1, by = 0.05), -->
<!--   xlab = "p-value" -->
<!-- ) -->
<!-- ``` -->

--- <i> END CODE ARCHIVE </i> ---


```{r SessionInfo}
# for record keeping
sessionInfo()
```

